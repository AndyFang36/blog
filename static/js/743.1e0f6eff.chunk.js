"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[743],{743:function(e,n,t){t.r(n),t.d(n,{default:function(){return h}});var o=t(885),r=t(7313),i=t(7829),a=t(1113),s=t(5898),c=t(6417);function u(e){return console.log("factorialOf(n) called!"),e<=0?1:e*u(e-1)}var l=function(){var e=(0,r.useState)(1),n=(0,o.Z)(e,2),t=n[0],s=n[1],l=(0,r.useState)(0),d=(0,o.Z)(l,2),h=d[0],m=d[1],p=u(t);return(0,c.jsxs)(i.Z,{className:"demo",children:[(0,c.jsxs)(a.Z,{variant:"h2",children:["\ud83d\udccc Demo 1: Without ",(0,c.jsx)("code",{children:"useMemo"})]}),(0,c.jsxs)(a.Z,{children:["Factorial of",(0,c.jsx)("input",{type:"number",value:t,onChange:function(e){s(Number(e.target.value))}}),"is ",p]}),(0,c.jsx)("button",{onClick:function(){return m((function(e){return e+1}))},children:"Re-render"}),": ",h]})},d=function(){var e=(0,r.useState)(1),n=(0,o.Z)(e,2),t=n[0],s=n[1],l=(0,r.useState)(0),d=(0,o.Z)(l,2),h=d[0],m=d[1],p=(0,r.useMemo)((function(){return u(t)}),[t]);return(0,c.jsxs)(i.Z,{className:"demo",children:[(0,c.jsxs)(a.Z,{variant:"h2",children:["\ud83d\udccc Demo 2: With ",(0,c.jsx)("code",{children:"useMemo"})]}),(0,c.jsxs)(a.Z,{children:["Factorial of",(0,c.jsx)("input",{type:"number",value:t,onChange:function(e){s(Number(e.target.value))}}),"is ",p]}),(0,c.jsx)("button",{onClick:function(){return m((function(e){return e+1}))},children:"Re-render"}),": ",h]})};function h(){return(0,c.jsxs)(i.Z,{id:"MemoHook",children:[(0,c.jsx)(a.Z,{variant:"h1",children:"useMemo() hook"}),(0,c.jsx)(a.Z,{variant:"body2",children:"useMemo() is a built-in React hook that accepts 2 arguments \u2014 a function compute that computes a result and the depedencies array: const memoizedResult = useMemo(compute, dependencies); During initial rendering, useMemo(compute, dependencies) invokes compute, memoizes the calculation result, and returns it to the component. If during next renderings the dependencies don't change, then useMemo() doesn't invoke compute but returns the memoized value. But if dependencies change during re-rendering, then useMemo() invokes compute, memoizes the new value, and returns it. That's the essence of useMemo() hook."}),(0,c.jsxs)(a.Z,{paragraph:!0,children:["each time you click Re-render button, inc state value is updated. Updating inc state value triggers ",(0,c.jsx)("code",{children:"CalculateFactorial"})," re-rendering. But, as a secondary effect, during re-rendering the factorial is recalculated again \u2014 'factorialOf(n) called!' is logged to console."]}),(0,c.jsx)(a.Z,{className:"tip",children:"\u8bf7\u901a\u8fc7\u63a7\u5236\u53f0\u6bd4\u8f83\u5dee\u5f02\uff01"}),(0,c.jsxs)(s.Z,{className:"demo-stack",spacing:5,children:[(0,c.jsx)(l,{}),(0,c.jsx)(d,{})]}),(0,c.jsx)(a.Z,{variant:"h6",children:"Use memoization with care: While useMemo() can improve the performance of the component, you have to make sure to profile the component with and without the hook. Only after that make the conclusion whether memoization worth it. When memoization is used inappropriately, it could harm the performance."})]})}}}]);