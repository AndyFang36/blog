{"version":3,"file":"static/js/863.2fdd3b04.chunk.js","mappings":"2MAGA,SAASA,EAAYC,GAEnB,OADAC,QAAQC,IAAI,0BACJF,GAAK,EAAK,EAAIA,EAAID,EAAYC,EAAI,GAG5C,IAAMG,EAAQ,WACZ,OAA4BC,EAAAA,EAAAA,UAAS,GAArC,eAAOC,EAAP,KAAeC,EAAf,KACA,GAAkBF,EAAAA,EAAAA,UAAS,GAA3B,eAAOG,EAAP,KAAUC,EAAV,KAEMC,EAAYV,EAAYM,GAM9B,OACE,UAAC,IAAD,CAAKK,UAAU,OAAf,WACE,UAAC,IAAD,CAAYC,QAAQ,KAApB,2CAA4C,0CAC5C,UAAC,IAAD,2BAAwB,kBAAOC,KAAK,SAASC,MAAOR,EAAQS,SAR/C,SAAAC,GACfT,EAAUU,OAAOD,EAAME,OAAOJ,WAO5B,MAAqFJ,MACrF,mBAAQS,QANI,kBAAMV,GAAK,SAAAD,GAAC,OAAIA,EAAI,MAMhC,uBAHF,KAGiDA,MAK/CY,EAAQ,WACZ,OAA4Bf,EAAAA,EAAAA,UAAS,GAArC,eAAOC,EAAP,KAAeC,EAAf,KACA,GAAkBF,EAAAA,EAAAA,UAAS,GAA3B,eAAOG,EAAP,KAAUC,EAAV,KAEMC,GAAYW,EAAAA,EAAAA,UAAQ,kBAAMrB,EAAYM,KAAS,CAACA,IAMtD,OACE,UAAC,IAAD,CAAKK,UAAU,OAAf,WACE,UAAC,IAAD,CAAYC,QAAQ,KAApB,wCAAyC,0CACzC,UAAC,IAAD,2BAAwB,kBAAOC,KAAK,SAASC,MAAOR,EAAQS,SAR/C,SAACO,GAChBf,EAAUU,OAAOK,EAAEJ,OAAOJ,WAOxB,MAAqFJ,MACrF,mBAAQS,QANI,kBAAMV,GAAK,SAAAD,GAAC,OAAIA,EAAI,MAMhC,uBAHF,KAGiDA,MAKtC,SAASe,IACtB,OACE,UAAC,IAAD,CAAKC,GAAG,WAAR,WACE,SAAC,IAAD,CAAYZ,QAAQ,KAApB,6BACA,SAAC,IAAD,CAAYA,QAAQ,QAApB,snBAYA,UAAC,IAAD,CAAYa,WAAS,EAArB,kHACsG,iDADtG,+JAGA,SAAC,IAAD,CAAYd,UAAU,MAAtB,iFACA,UAAC,IAAD,CAAOA,UAAU,aAAae,QAAS,EAAvC,WACE,SAACtB,EAAD,KACA,SAACgB,EAAD,QAEF,SAAC,IAAD,CAAYR,QAAQ,KAApB","sources":["app/pages/tech/react/hooks/MemoHook.jsx"],"sourcesContent":["import {useMemo, useState} from \"react\";\r\nimport {Box, Stack, Typography} from \"@mui/material\";\r\n\r\nfunction factorialOf(n) {\r\n  console.log(\"factorialOf(n) called!\");\r\n  return (n <= 0) ? 1 : n * factorialOf(n - 1);\r\n}\r\n\r\nconst Demo1 = () => {\r\n  const [number, setNumber] = useState(1);\r\n  const [i, setI] = useState(0);\r\n\r\n  const factorial = factorialOf(number);\r\n  const onChange = event => {\r\n    setNumber(Number(event.target.value));\r\n  };\r\n  const onClick = () => setI(i => i + 1);\r\n\r\n  return (\r\n    <Box className=\"demo\">\r\n      <Typography variant=\"h2\">üìå Demo 1: Without <code>useMemo</code></Typography>\r\n      <Typography>Factorial of<input type=\"number\" value={number} onChange={onChange}/>is {factorial}</Typography>\r\n      <button onClick={onClick}>Re-render</button>: {i}\r\n    </Box>\r\n  );\r\n};\r\n\r\nconst Demo2 = () => {\r\n  const [number, setNumber] = useState(1);\r\n  const [i, setI] = useState(0);\r\n\r\n  const factorial = useMemo(() => factorialOf(number), [number]);\r\n  const onChange = (e) => {\r\n    setNumber(Number(e.target.value));\r\n  };\r\n  const onClick = () => setI(i => i + 1);\r\n\r\n  return (\r\n    <Box className=\"demo\">\r\n      <Typography variant=\"h2\">üìå Demo 2: With <code>useMemo</code></Typography>\r\n      <Typography>Factorial of<input type=\"number\" value={number} onChange={onChange}/>is {factorial}</Typography>\r\n      <button onClick={onClick}>Re-render</button>: {i}\r\n    </Box>\r\n  );\r\n};\r\n\r\nexport default function MemoHook() {\r\n  return (\r\n    <Box id=\"MemoHook\">\r\n      <Typography variant=\"h1\">useMemo() hook</Typography>\r\n      <Typography variant=\"body2\">\r\n        useMemo() is a built-in React hook that accepts 2 arguments ‚Äî a function compute that computes a result and the depedencies array:\r\n\r\n        const memoizedResult = useMemo(compute, dependencies);\r\n        During initial rendering, useMemo(compute, dependencies) invokes compute, memoizes the calculation result, and returns it to the component.\r\n\r\n        If during next renderings the dependencies don't change, then useMemo() doesn't invoke compute but returns the memoized value.\r\n\r\n        But if dependencies change during re-rendering, then useMemo() invokes compute, memoizes the new value, and returns it.\r\n\r\n        That's the essence of useMemo() hook.\r\n      </Typography>\r\n      <Typography paragraph>\r\n        each time you click Re-render button, inc state value is updated. Updating inc state value triggers <code>CalculateFactorial</code> re-rendering. But, as a secondary effect, during re-rendering the factorial is recalculated again ‚Äî 'factorialOf(n) called!' is logged to console.\r\n      </Typography>\r\n      <Typography className=\"tip\">ËØ∑ÈÄöËøáÊéßÂà∂Âè∞ÊØîËæÉÂ∑ÆÂºÇÔºÅ</Typography>\r\n      <Stack className=\"demo-stack\" spacing={5}>\r\n        <Demo1/>\r\n        <Demo2/>\r\n      </Stack>\r\n      <Typography variant=\"h6\">\r\n        Use memoization with care:\r\n        While useMemo() can improve the performance of the component, you have to make sure to profile the component\r\n        with and without the hook. Only after that make the conclusion whether memoization worth it. When memoization\r\n        is used inappropriately, it could harm the performance.\r\n      </Typography>\r\n    </Box>\r\n  );\r\n};\r\n"],"names":["factorialOf","n","console","log","Demo1","useState","number","setNumber","i","setI","factorial","className","variant","type","value","onChange","event","Number","target","onClick","Demo2","useMemo","e","MemoHook","id","paragraph","spacing"],"sourceRoot":""}